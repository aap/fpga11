
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
`default_nettype none

`define KT11
`define KJ11
`define KE11E

`define TU58

module toplevel(

	//////////// CLOCK //////////
	input 		          		CLOCK_125_p,
	input 		          		CLOCK_50_B5B,
	input 		          		CLOCK_50_B6A,
	input 		          		CLOCK_50_B7A,
	input 		          		CLOCK_50_B8A,

	//////////// LED //////////
	output		     [7:0]		LEDG,
	output		     [9:0]		LEDR,

	//////////// KEY //////////
	input 		          		CPU_RESET_n,
	input 		     [3:0]		KEY,
	
	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// HDMI-TX //////////
	output		          		HDMI_TX_CLK,
	output		    [23:0]		HDMI_TX_D,
	output		          		HDMI_TX_DE,
	output		          		HDMI_TX_HS,
	input 		          		HDMI_TX_INT,
	output		          		HDMI_TX_VS,

	//////////// I2C for Audio/HDMI-TX/Si5338/HSMC //////////
	output		          		I2C_SCL,
	inout 		          		I2C_SDA,

	//////////// Uart to USB //////////
	input 		          		UART_RX,
	output		          		UART_TX,

	//////////// GPIO, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		GPIO
);
	wire clock50 = CLOCK_50_B5B;
	wire clk = clock50;
	wire reset;
	syncreset syncreset(clock50, ~CPU_RESET_n, reset);

/*
//	reg [7:0] resetsync = ~0;
	reg resetsync_n = 0;
	always @(posedge clk) begin
//			if(~CPU_RESET_n)
//				resetsync[7:0] <= ~0;
//			else
//				resetsync[7:0] <= {resetsync[6:0], 1'b0};
			resetsync_n <= CPU_RESET_n; //|resetsync;
	end

	wire reset_n = resetsync_n;
//	wire reset_n = CPU_RESET_n;
	wire reset = ~reset_n;
*/

	reg [11:0] columns;
	reg [2:0] switch_rows;
	reg [5:0] led_rows;

	reg panel_init = 0;
	reg enable_out = 0;
	wire sw_mode = (|switch_rows) & enable_out;
	wire led_mode = (|led_rows) & enable_out;

	assign GPIO[19] = led_mode ? led_rows[0] : 1'bz;	// LED0
	assign GPIO[22] = led_mode ? led_rows[1] : 1'bz;
	assign GPIO[7] = led_mode ? led_rows[2] : 1'bz;
	assign GPIO[4] = led_mode ? led_rows[3] : 1'bz;
	assign GPIO[2] = led_mode ? led_rows[4] : 1'bz;
	assign GPIO[0] = led_mode ? led_rows[5] : 1'bz;	// LED5

	assign GPIO[17] = switch_rows[0] ? 1'b0 : 1'bz;	// SW0
	assign GPIO[3] = switch_rows[1] ? 1'b0 : 1'bz;
	assign GPIO[6] = switch_rows[2] ? 1'b0 : 1'bz;	// SW2

	assign GPIO[20] = led_mode ? ~columns[0] : 1'bz;	// COL0
	assign GPIO[5] = led_mode ? ~columns[1] : 1'bz;
	assign GPIO[1] = led_mode ? ~columns[2] : 1'bz;
	assign GPIO[16] = led_mode ? ~columns[3] : 1'bz;
	assign GPIO[18] = led_mode ? ~columns[4] : 1'bz;
	assign GPIO[13] = led_mode ? ~columns[5] : 1'bz;
	assign GPIO[11] = led_mode ? ~columns[6] : 1'bz;
	assign GPIO[12] = led_mode ? ~columns[7] : 1'bz;
	assign GPIO[10] = led_mode ? ~columns[8] : 1'bz;
	assign GPIO[14] = led_mode ? ~columns[9] : 1'bz;
	assign GPIO[15] = led_mode ? ~columns[10] : 1'bz;
	assign GPIO[23] = led_mode ? ~columns[11] : 1'bz;	// COL11

	wire [11:0] columns_in;

	assign columns_in[0] = sw_mode ? GPIO[20] : 1'b1;
	assign columns_in[1] = sw_mode ? GPIO[5] : 1'b1;
	assign columns_in[2] = sw_mode ? GPIO[1] : 1'b1;
	assign columns_in[3] = sw_mode ? GPIO[16] : 1'b1;
	assign columns_in[4] = sw_mode ? GPIO[18] : 1'b1;
	assign columns_in[5] = sw_mode ? GPIO[13] : 1'b1;
	assign columns_in[6] = sw_mode ? GPIO[11] : 1'b1;
	assign columns_in[7] = sw_mode ? GPIO[12] : 1'b1;
	assign columns_in[8] = sw_mode ? GPIO[10] : 1'b1;
	assign columns_in[9] = sw_mode ? GPIO[14] : 1'b1;
	assign columns_in[10] = sw_mode ? GPIO[15] : 1'b1;
	assign columns_in[11] = sw_mode ? GPIO[23] : 1'b1;

	reg [3:0] row_addr = 0;

//	reg [15:0] data_reg = 1;
//	reg [21:0] addr_reg = 1;
//	reg [11:0] status_reg = 'o7777;
	reg [1:0] parity_reg = 2'b00;
	reg [2:0] addr_sel = 0;
	reg [1:0] data_sel = 0;
	wire [7:0] addr_sel_dec = 0; //1<<addr_sel;
	wire [3:0] data_sel_dec = 0; //1<<data_sel;
	reg [21:0] data_sw;
	reg [7:0] ctrl_sw;
	reg [3:0] rotary_raw;

/*
	always @(posedge clk) begin
		if(reset) begin
			data_reg <= 1;
			addr_reg <= 1;
		end else begin
/ *
			if(key_pressed[0]) begin
				data_reg <= {data_reg[14:0], data_reg[15]};
				addr_reg <= {addr_reg[0], addr_reg[21:1]};
			end
			if(key_pressed[1]) begin
				addr_reg <= data_sw;
				data_reg <= ctrl_sw;
				status_reg <= {rotary_raw, ctrl_sw};
			end
* /

			columns_latched <= columns_in;
			if(key_pressed[2])
				row_addr <= SW;
		end
	end
*/


	always @(*) begin
		columns <= 0;
		case(row_addr)
		4'h0: columns <= addr_reg[11:0];
		4'h1: columns <= addr_reg[21:12];
		4'h2: columns <= status_reg70;
		4'h3: columns <= data_reg[11:0];
		4'h4: columns <= {data_sel_dec[1:0], addr_sel_dec[3:0], parity_reg, data_reg[15:12]};
		4'h5: columns <= {data_sel_dec[3:2], addr_sel_dec[7:4], 6'b0};
		endcase
	end

	reg [15:0] uscounter;
	wire clk_us = uscounter == 0;
	always @(posedge clk) begin
		if(reset) begin
			uscounter <= 0;
		end else begin
			if(uscounter == 50-1)
				uscounter <= 0;
			else
				uscounter <= uscounter + 1;
		end
	end

	reg [15:0] us;
	always @(posedge clk) begin
		if(reset) begin
			us <= 0;
			panel_init <= 0;
			enable_out <= 0;
		end else begin
			if(clk_us) begin

				if(us == 0) begin
					enable_out <= 1;
					if(row_addr == 8) begin
						panel_init <= 1;
						row_addr <= 0;
					end else
						row_addr <= row_addr + 1;
				end

				if(|led_rows) begin
					// LED timing
					if(us == 2500)
						us <= 0;
					else
						us <= us + 1;

					if(us == 2500)
						enable_out <= 0;
				end

				if(|switch_rows) begin
					// Switch timing
					if(us == 3000)
						us <= 0;
					else
						us <= us + 1;
					if(us == 3000) begin
						if(switch_rows[0]) data_sw[11:0] <= ~columns_in[11:0];
						if(switch_rows[1]) data_sw[21:12] <= ~columns_in[9:0];
						if(switch_rows[2]) begin
							ctrl_sw <= {~columns_in[7:1], columns_in[0]};
							rotary_raw <= ~columns_in[11:8];
						end
					end
				end
			end


//			addr_reg <= data_sw;
//			data_reg <= ctrl_sw;
//			status_reg <= {rotary_raw, ctrl_sw};
		end
	end

	// decode address
	always @(*) begin
		switch_rows <= 0;
		led_rows <= 0;
		case(row_addr)
		4'h0: led_rows[0] <= 1;
		4'h1: led_rows[1] <= 1;
		4'h2: led_rows[2] <= 1;
		4'h3: led_rows[3] <= 1;
		4'h4: led_rows[4] <= 1;
		4'h5: led_rows[5] <= 1;
		4'h6: switch_rows[0] <= 1;
		4'h7: switch_rows[1] <= 1;
		4'h8: switch_rows[2] <= 1;
		endcase
	end


//	assign LEDG[7:0] = 0;
//	assign LEDR[9:0] = 0;

	wire [3:0] key_pressed;
	edgedet e0(clk, reset, ~KEY[0], key_pressed[0]);
	edgedet e1(clk, reset, ~KEY[1], key_pressed[1]);
	edgedet e2(clk, reset, ~KEY[2], key_pressed[2]);
	edgedet e3(clk, reset, ~KEY[3], key_pressed[3]);








	wire[15:0] data_reg;
	wire[21:0] addr_reg;
	wire[5:0] status_reg;
	wire[11:0] status_reg70;
	assign addr_reg[21:18] = 0;
	assign status_reg70[11] = 0;	// par err
	assign status_reg70[10] = 0;	// adrs err
	assign status_reg70[9] = ~status_reg[1];	// run		~console
	assign status_reg70[8] = ~status_reg[5];	// pause		~run (micro machine)			TODO: this doesn't make much sense
	assign status_reg70[7] = status_reg[2];	// master
	assign status_reg70[6] = status_reg[3];	// user
	assign status_reg70[5] = 0;	// super
	assign status_reg70[4] = ~status_reg[3];	// kernel
	assign status_reg70[3] = 0;	//	data
	assign status_reg70[2] = ~status_reg[0];	// 16bit addr
	assign status_reg70[1] = status_reg[0];	// 18bit addr
	assign status_reg70[0] = 0;	// 22bit addr
	wire [8:0] bupp;
	wire [8:0] pupp;
	wire [4:0] ps_flags;
	wire [2:0] cpu_status;

//	assign LEDR[8:0] = SW[0] ? bupp : pupp;
	assign LEDG[7:0] = {cpu_status, ps_flags};

	// power up machine only after we've read
	// the panel once because it need to know
	// the position of some switches
	reg power = 0;
	always @(posedge clk) begin
		if(reset)
			power <= 0;
		else
			power <= panel_init;
	end

	pdp11_40 pdp11(.clk(clk), .reset(reset),
		.power(power),
		.ldadrs_sw(ctrl_sw[1]),
		.exam_sw(ctrl_sw[2]),
		.dep_sw(ctrl_sw[3]),
		.cont_sw(ctrl_sw[4]),
		.start_sw(ctrl_sw[7]),
		.begin_sw(1'b0),
		.halt_sw(ctrl_sw[5]),
		.sr(data_sw[17:0]),

		.addr_lights(addr_reg[17:0]),
		.data_lights(data_reg),
		.status_lights(status_reg),

		.mclk_enable(data_sw[21]),
		.mclk(ctrl_sw[0]),
		.mstop(data_sw[20]),
		.bupp(bupp),
		.pupp(pupp),
		.flags(ps_flags),
		.status(cpu_status),

		.cnsl_RX(serial_cnsl_in),
		.cnsl_TX(serial_cnsl_out),
		.tu58_RX(serial_tu58_in),
		.tu58_TX(serial_tu58_out),

		.enable_M9312(SW[9])
	);

	wire serial_USB_out = UART_RX;
	assign UART_TX = serial_USB_in;

	wire serial_cnsl_out;
	wire serial_vt_out;
	wire serial_tu58_out;
`ifdef TU58
	wire serial_tu58_in = serial_USB_out;
	wire serial_cnsl_in = serial_vt_out;
	wire serial_USB_in = serial_tu58_out;
`else
	wire serial_tu58_in = 1;
	wire serial_cnsl_in = serial_USB_out & serial_vt_out;
	wire serial_USB_in = serial_cnsl_out;
`endif
	wire serial_vt_in = serial_cnsl_out;


//	assign LEDR[9] = hdmi_ready;

	// control video inversion with switch
	wire invert = SW[1];
	wire bell_inverts = SW[2];

	wire hdmi_ready;
	pseudo_vt52 vt(.clock50(clk), .async_reset(~CPU_RESET_n),
		.invert_video(invert),
		.bell_inverts(bell_inverts),

		.HDMI_TX_CLK(HDMI_TX_CLK),
		.HDMI_TX_D(HDMI_TX_D),
		.HDMI_TX_DE(HDMI_TX_DE),
		.HDMI_TX_HS(HDMI_TX_HS),
		.HDMI_TX_INT(HDMI_TX_INT),
		.HDMI_TX_VS(HDMI_TX_VS),
		.hdmi_ready(hdmi_ready),

		.I2C_SCL(I2C_SCL),
		.I2C_SDA(I2C_SDA),

		.UART_RX(serial_vt_in),
		.UART_TX(serial_vt_out),

		.ps2_clk(GPIO[28]),
		.ps2_data(GPIO[29])
	);
endmodule
